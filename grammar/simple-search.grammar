{
  const findLeftMostOperator = (node) => {
    if (!node) {
      return null;
    }
    
    if (node.operator) {
      return node;
    }
    
    if (!node.left) {
      return node;
    }
    
    return findLeftMostOperator(node.left);
  };
  
  function buildTermTree(terms) {
    if (terms.length === 1) {
      return terms[0];
    }

    return {
      operator: "AND",
      left: terms[0],
      right: buildTermTree(terms.slice(1))
    };
  }
  
  function buildOrTree(terms) {
    if (terms.length === 1) {
      return terms[0];
    }

    return {
      operator: "OR",
      left: terms[0],
      right: buildOrTree(terms.slice(1))
    };
  }  
}

Expr
  = Or_Expr

Or_Expr
  = head:And_Expr tail:(_* "OR"? _* And_Expr)*
  	{
      let left = head;
      let right;
      let operator;

      // this is a bit hairy and ugly
      if (!head.operator && head.left && head.left.operator === "NOT") {
        return findLeftMostOperator(head);
      } else if (tail.length == 1) {
        operator = tail[1] ? tail[1] : "<implicit>";
        // left = head.operator ? head : head.left;
        right = tail[0][3].operator
        		? tail[0][3]
                : tail[0][3].left
                  ? tail[0][3].left
                  : tail[0][3];
      }
      
      if (!operator && !tail.length) {
      	return left;
      }
      
  	  const terms = tail.map(term => term[3]);
      return buildOrTree([head, ...terms]);
    }

And_Expr
  = first:Not_Expr _* "," _* second:Not_Expr _* tail:(_* "," _* Not_Expr)*
    {
	  const terms = tail.map(term => term[3]);
      return buildTermTree([first, second, ...terms]);
    }
  / head:Not_Expr tail:(_+ "AND" _+ Not_Expr)*
    {
	  const terms = tail.map(term => term[3]);
      return buildTermTree([head, ...terms]);
    }

Not_Expr
  = "(" expr:Expr ")" { return expr; }
  / "NOT" _+ right:Term
    {
      return {
        operator: "NOT",
        right
      }
    }
  / head:(Term _+)? "NOT" _+ right:Term
    {
      let left = null;
      
      if (head) {
        left = head[0]
      }

      return {
        operator: "NOT",
        left: left,
        right
      }
    }
  / term:Term

Term
  = "\"" term:[^"]+ "\"" 
    {
      return {
        type: 'phrase',
        value: term.join("")
      }
    }
  / term:[a-zA-Z0-9]+ 
    {
      return {
        type: 'term',
        value: term.join("")
      }
    }

_ "whitespace"
  = [ \t\n\r]
